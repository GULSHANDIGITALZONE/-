<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruits Crush Game</title>
<style>
  :root{ --cols:6; --rows:8; --gap:8px; --tile-size: min(68px, calc((100vmin - 40px)/var(--rows))); }
  *{box-sizing:border-box;font-family:Inter, system-ui, Arial, sans-serif}
  body{ margin:0; min-height:100vh; display:flex; align-items:flex-start; justify-content:center; padding:18px; background:linear-gradient(180deg,#e74040,#9395f3,rgb(0, 255, 64)); color:#e6eef8; }
  .container{ display:flex; gap:18px; width:100%; max-width:1200px; align-items:flex-start; justify-content:center; }
  .panel{ width:300px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); padding:14px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.6); }
  h1{ margin:0 0 8px; font-size:18px }
  .score{ font-size:36px; font-weight:800; color:#ffe57f; text-align:center; margin: 0px 0; }
  .meta{ display:flex; gap:8px; justify-content:space-between; margin-top:6px; }
  button{ background:#0256f1; color:#e6eef8; border:1px solid rgba(255,255,255,0.03); padding:10px; border-radius:8px; cursor:pointer; font-weight:700; }
  .small{ padding:8px; font-size:13px; }
  .board-wrap{ display:flex; flex-direction:column; gap:12px; align-items:center; }
  .board{ display:grid; grid-template-columns: repeat(var(--cols), var(--tile-size)); grid-template-rows: repeat(var(--rows), var(--tile-size)); gap:var(--gap); padding:12px; background:linear-gradient(180deg,#ff5c1b,#8db1f5,rgb(0, 255, 0)); border-radius:14px; box-shadow: 0 10px 30px rgba(10, 247, 49, 0.7); -webkit-user-select:none; -ms-user-select:none; user-select:none; touch-action: manipulation; }
  .tile{ width:var(--tile-size); height:var(--tile-size); border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:32px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06)); transition: transform 140ms ease, opacity 140ms ease; cursor:grab; position:relative; }
  .tile.dragging{ transform: scale(1.05); z-index:10; opacity:0.98; cursor:grabbing; }
  .selected{ outline:3px solid rgba(255,255,255,0.07); box-shadow:0 8px 18px rgba(0,0,0,0.6); }
  /* emoji span */
  .emoji-span{ pointer-events:none; font-size:40px; line-height:1; }
  /* striped overlay */
  .stripe-mark{ position:absolute; inset:6%; border-radius:10px; pointer-events:none; mix-blend-mode:overlay; display:none; }
  .stripe-h{ background-image: repeating-linear-gradient(90deg, rgba(255,255,255,0.35) 0 8%, transparent 8% 16%); opacity:0.9; transform: rotate(0deg); }
  .stripe-v{ background-image: repeating-linear-gradient(180deg, rgba(255,255,255,0.35) 0 8%, transparent 8% 16%); opacity:0.9; transform: rotate(0deg); }
  .bomb-mark{ position:absolute; inset:12%; display:none; align-items:center; justify-content:center; font-size:20px; pointer-events:none; }
  .hud-row{ display:flex; gap:8px; justify-content:space-between; margin-top:8px; align-items:center; }
  @media(max-width:880px){ body{padding:12px} .container{flex-direction:column; align-items:center} .panel{order:2;width:100%} }
</style>
</head>
<body>

<div class="container">
  <div class="panel">
    <h1 style="color: blue;">Function</h1>

    <div class="meta" style="margin-top:12px">
      <div>Level</div><div id="levelLabel">1</div>
    </div>
    <div class="score" id="score">0</div>

    <div class="meta">
      <div>Target</div><div id="targetLabel">500</div>
    </div>
    <div class="meta" style="margin-top:6px">
      <div>Moves</div><div id="movesLabel">30</div>
    </div>
    <div class="meta" style="margin-top:6px">
      <div>Timer</div><div id="timerLabel">â€”</div>
    </div>

    <div class="hud-row" style="margin-top:12px">
      <button id="btnNew">Naya Game</button>
      <button id="btnHint" class="small">Hint</button>
    </div>
    <div class="hud-row" style="margin-top:8px">
      <button id="btnSound" class="small">Sound: ON</button>
      <button id="btnNextLevel" class="small">Next Level</button>
    </div>

   
  </div>

  <div class="board-wrap">
    <div id="board" class="board" aria-label="Game board"></div>
  </div>
</div>

<script>
/* ---------------------------
   Configuration & state
   ---------------------------*/
const ROWS = 8, COLS = 6;
const FRUITS = ['ðŸ’','ðŸŠ','ðŸ‹','ðŸ‡','ðŸ‰','ðŸŽ']; // emojis
const boardEl = document.getElementById('board');
let board = []; // {el, type: null|'normal'|'striped'|'bomb', emoji: 'ðŸ’', stripeDir: 'h'|'v'}
let score = 0;
let level = 1;
let movesLeft = 30;
let timerSeconds = null;
let timerInterval = null;
let animOn = true;
let soundOn = true;
let resolving = false;

/* Level definitions */
const LEVELS = [
  {target:500, moves:30, timer:null},
  {target:1500, moves:25, timer:null},
  {target:3500, moves:40, timer:90},
  {target:7000, moves:35, timer:null},
  {target:12000, moves:30, timer:60}
];
function getCurrentLevelDef(){ return LEVELS[Math.min(level-1, LEVELS.length-1)]; }

/* Audio helpers */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(!AudioCtx) return; if(!audioCtx) audioCtx = new AudioCtx(); }
function beep(freq=440,duration=0.08, type='sine', vol=0.08){
  if(!soundOn) return;
  ensureAudio();
  if(!audioCtx) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + duration);
}

/* ---------------------------
   DOM tile creation & visuals (FIXED)
   ---------------------------*/
function makeTileElement(r,c){
  const el = document.createElement('div');
  el.className = 'tile';
  el.dataset.r = r; el.dataset.c = c;
  el.setAttribute('draggable','true');

  // emoji span (dedicated)
  const emojiSpan = document.createElement('span');
  emojiSpan.className = 'emoji-span';
  emojiSpan.style.pointerEvents = 'none';
  el.appendChild(emojiSpan);

  // stripe and bomb markers (kept separate so they are not removed)
  const stripe = document.createElement('div');
  stripe.className = 'stripe-mark';
  stripe.style.display = 'none';
  el.appendChild(stripe);

  const bombMark = document.createElement('div');
  bombMark.className = 'bomb-mark';
  bombMark.style.display = 'none';
  el.appendChild(bombMark);

  // events desktop drag/drop
  el.addEventListener('dragstart', e=>{
    el.classList.add('dragging');
    e.dataTransfer.setData('text/plain', `${r},${c}`);
    setTimeout(()=>el.classList.add('hideme'),0);
  });
  el.addEventListener('dragend', ()=>{ el.classList.remove('dragging'); el.classList.remove('hideme'); });

  el.addEventListener('dragover', e=>e.preventDefault());
  el.addEventListener('drop', e=>{
    e.preventDefault();
    const data = e.dataTransfer.getData('text/plain');
    if(!data) return;
    const [r1,c1] = data.split(',').map(Number);
    attemptSwap(r1,c1,r,c);
  });

  // click/touch for mobile
  el.addEventListener('click', ()=> {
    handleSelectClick(r,c,el);
  });

  // swipe handling
  let touchStart = null;
  el.addEventListener('touchstart', e=>{ touchStart = e.changedTouches[0]; }, {passive:true});
  el.addEventListener('touchend', e=>{
    const t = e.changedTouches[0];
    if(!touchStart) return;
    const dx = t.clientX - touchStart.clientX, dy = t.clientY - touchStart.clientY;
    if(Math.abs(dx)<18 && Math.abs(dy)<18) { handleSelectClick(r,c,el); touchStart=null; return; }
    const dir = Math.abs(dx) > Math.abs(dy) ? (dx>0?'right':'left') : (dy>0?'down':'up');
    let r2=r, c2=c;
    if(dir==='right') c2++;
    if(dir==='left') c2--;
    if(dir==='down') r2++;
    if(dir==='up') r2--;
    if(inBounds(r2,c2)) attemptSwap(r,c,r2,c2);
    touchStart=null;
  }, {passive:true});

  return el;
}

function setTileVisual(cell){
  const el = cell.el;
  const emojiSpan = el.querySelector('.emoji-span');
  const stripe = el.querySelector('.stripe-mark');
  const bombMark = el.querySelector('.bomb-mark');

  // reset visuals
  stripe.style.display = 'none';
  bombMark.style.display = 'none';
  emojiSpan.textContent = '';

  el.classList.remove('selected','dragging');

  if(!cell.type && !cell.emoji){
    el.style.opacity = '0';
    el.style.transform = 'scale(0.96)';
    return;
  }

  el.style.opacity = '1';
  el.style.transform = 'scale(1)';

  if(cell.type === 'bomb'){
    bombMark.style.display = 'flex';
    bombMark.textContent = 'ðŸ’£';
  } else {
    emojiSpan.textContent = cell.emoji || '';
    if(cell.type === 'striped'){
      stripe.style.display = 'block';
      stripe.className = 'stripe-mark ' + (cell.stripeDir === 'h' ? 'stripe-h' : 'stripe-v');
    }
  }
}

/* ---------------------------
   Board init & refill
   ---------------------------*/
function initBoard(){
  board = [];
  boardEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    const row = [];
    for(let c=0;c<COLS;c++){
      const el = makeTileElement(r,c);
      boardEl.appendChild(el);
      row.push({el, type:null, emoji:null, stripeDir:null});
    }
    board.push(row);
  }
  // fill without initial matches
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      do {
        board[r][c].emoji = FRUITS[Math.floor(Math.random()*FRUITS.length)];
        board[r][c].type = 'normal';
        board[r][c].stripeDir = null;
      } while(checkImmediateMatchAt(r,c));
      setTileVisual(board[r][c]);
    }
  }
  score = 0; updateHUD();
}

function checkImmediateMatchAt(r,c){
  const e = board[r][c].emoji;
  if(c>=2 && board[r][c-1].emoji === e && board[r][c-2].emoji === e) return true;
  if(r>=2 && board[r-1][c].emoji === e && board[r-2][c].emoji === e) return true;
  return false;
}

/* ---------------------------
   Utility & helpers
   ---------------------------*/
function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
function updateHUD(){
  document.getElementById('score').textContent = score;
  document.getElementById('levelLabel').textContent = level;
  const def = getCurrentLevelDef();
  document.getElementById('targetLabel').textContent = def.target;
  document.getElementById('movesLabel').textContent = movesLeft;
  document.getElementById('timerLabel').textContent = timerSeconds === null ? 'â€”' : formatTime(timerSeconds);
}
function formatTime(s){ const mm = Math.floor(s/60); const ss = s%60; return `${mm}:${ss.toString().padStart(2,'0')}`; }

/* ---------------------------
   Matching detection
   ---------------------------*/
function findAllMatches(){
  const groups = [];
  // horizontal
  for(let r=0;r<ROWS;r++){
    let c=0;
    while(c < COLS){
      if(!board[r][c].emoji){ c++; continue; }
      const start = c, emoji = board[r][c].emoji;
      while(c+1 < COLS && board[r][c+1].emoji === emoji) c++;
      const len = c - start + 1;
      if(len >= 3){
        const cells = [];
        for(let x=start;x<=c;x++) cells.push({r, c:x});
        groups.push({cells, len, dir:'h', emoji});
      }
      c++;
    }
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let r=0;
    while(r < ROWS){
      if(!board[r][c].emoji){ r++; continue; }
      const start = r, emoji = board[r][c].emoji;
      while(r+1 < ROWS && board[r+1][c].emoji === emoji) r++;
      const len = r - start + 1;
      if(len >= 3){
        const cells = [];
        for(let x=start;x<=r;x++) cells.push({r:x, c});
        groups.push({cells, len, dir:'v', emoji});
      }
      r++;
    }
  }
  return groups;
}

/* ---------------------------
   Resolve matches: specials, remove, gravity, refill, chain
   ---------------------------*/
async function resolveMatchesChain(){
  if(resolving) return;
  resolving = true;
  while(true){
    const groups = findAllMatches();
    if(groups.length === 0) break;

    const remove = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    const specials = [];
    for(const g of groups){
      for(const cell of g.cells) remove[cell.r][cell.c] = true;
      if(g.len === 4){
        const pos = (g.dir==='h') ? g.cells[Math.random()<0.5?0:g.cells.length-1] : g.cells[Math.random()<0.5?0:g.cells.length-1];
        specials.push({r:pos.r, c:pos.c, type:'striped', stripeDir: g.dir==='h' ? 'h' : 'v', emoji: g.emoji});
      }
      if(g.len >= 5){
        const pos = g.cells[Math.floor(Math.random()*g.cells.length)];
        specials.push({r:pos.r, c:pos.c, type:'bomb'});
      }
    }

    let removedCount=0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(remove[r][c]){
          removedCount++;
          board[r][c].type = null; board[r][c].emoji = null; board[r][c].stripeDir = null;
          setTileVisual(board[r][c]);
        }
      }
    }
    score += removedCount * 60;
    beep(880, 0.07, 'sine', 0.06);
    updateHUD();

    for(const sp of specials){
      if(!inBounds(sp.r,sp.c)) continue;
      if(sp.type === 'striped'){
        board[sp.r][sp.c].type = 'striped';
        board[sp.r][sp.c].emoji = sp.emoji || FRUITS[Math.floor(Math.random()*FRUITS.length)];
        board[sp.r][sp.c].stripeDir = sp.stripeDir || 'h';
        setTileVisual(board[sp.r][sp.c]);
      } else if(sp.type === 'bomb'){
        board[sp.r][sp.c].type = 'bomb';
        board[sp.r][sp.c].emoji = null;
        board[sp.r][sp.c].stripeDir = null;
        setTileVisual(board[sp.r][sp.c]);
      }
    }

    await sleep(animOn?180:30);
    applyGravity();
    await sleep(animOn?160:30);
    refillBoard();
    await sleep(animOn?160:30);
  }
  resolving = false;
}

/* gravity & refill */
function applyGravity(){
  for(let c=0;c<COLS;c++){
    let write = ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(board[r][c].emoji || board[r][c].type){
        if(write !== r){
          board[write][c].emoji = board[r][c].emoji;
          board[write][c].type = board[r][c].type;
          board[write][c].stripeDir = board[r][c].stripeDir;
          board[r][c].emoji = null; board[r][c].type = null; board[r][c].stripeDir = null;
        }
        write--;
      }
    }
    for(let r=write;r>=0;r--){
      board[r][c].emoji = null; board[r][c].type = null; board[r][c].stripeDir = null;
    }
  }
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) setTileVisual(board[r][c]);
}

function refillBoard(){
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++){
      if(!board[r][c].emoji && !board[r][c].type){
        const rnd = Math.random();
        if(rnd < 0.03){
          board[r][c].type = 'bomb'; board[r][c].emoji = null;
        } else {
          board[r][c].emoji = FRUITS[Math.floor(Math.random()*FRUITS.length)];
          board[r][c].type = 'normal'; board[r][c].stripeDir = null;
        }
        setTileVisual(board[r][c]);
      }
    }
  }
}

/* ---------------------------
   Specials activation functions
   ---------------------------*/
function activateStripedAt(r,c){
  const dir = board[r][c].stripeDir || 'h';
  const removed = [];
  if(dir === 'h'){
    for(let cc=0; cc<COLS; cc++){
      if(board[r][cc].emoji || board[r][cc].type){
        removed.push({r, c:cc});
        board[r][cc].emoji = null; board[r][cc].type = null; board[r][cc].stripeDir = null;
        setTileVisual(board[r][cc]);
      }
    }
  } else {
    for(let rr=0; rr<ROWS; rr++){
      if(board[rr][c].emoji || board[rr][c].type){
        removed.push({r:rr, c});
        board[rr][c].emoji = null; board[rr][c].type = null; board[rr][c].stripeDir = null;
        setTileVisual(board[rr][c]);
      }
    }
  }
  score += removed.length * 90;
  beep(720,0.09,'sawtooth',0.07);
  return removed.length;
}

function activateBombWithColor(rBomb,cBomb, colorEmoji){
  let cleared = 0;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(board[r][c].emoji === colorEmoji){
      board[r][c].emoji = null; board[r][c].type = null; board[r][c].stripeDir = null;
      setTileVisual(board[r][c]); cleared++;
    }
  }
  board[rBomb][cBomb].type = null; board[rBomb][cBomb].emoji = null;
  setTileVisual(board[rBomb][cBomb]);
  score += cleared * 120;
  beep(140,0.14,'triangle',0.12);
  return cleared;
}

function clearAllLarge(){
  let cleared = 0;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(board[r][c].emoji || board[r][c].type){
      board[r][c].emoji = null; board[r][c].type = null; board[r][c].stripeDir = null;
      setTileVisual(board[r][c]); cleared++;
    }
  }
  score += cleared * 80;
  beep(200,0.25,'sine',0.14);
  return cleared;
}

/* ---------------------------
   Swap logic with combos
   ---------------------------*/
async function attemptSwap(r1,c1,r2,c2){
  if(!inBounds(r1,c1) || !inBounds(r2,c2)) return;
  if(resolving) return;
  const dr = Math.abs(r1-r2), dc = Math.abs(c1-c2);
  if(!((dr===1 && dc===0) || (dr===0 && dc===1))) return;

  const aType = board[r1][c1].type, bType = board[r2][c2].type;
  const aEmoji = board[r1][c1].emoji, bEmoji = board[r2][c2].emoji;

  async function animateSwapVisual(r1,c1,r2,c2){
    const el1 = board[r1][c1].el, el2 = board[r2][c2].el;
    el1.classList.add('dragging'); el2.classList.add('dragging');
    setTileVisual(board[r1][c1]); setTileVisual(board[r2][c2]);
    await sleep(animOn?160:20);
    el1.classList.remove('dragging'); el2.classList.remove('dragging');
  }

  // combos
  if(aType === 'bomb' && bType === 'bomb'){
    clearAllLarge();
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(260);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }
  if(aType === 'bomb' && bType !== 'bomb' && bEmoji){
    activateBombWithColor(r1,c1,bEmoji);
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(220);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }
  if(bType === 'bomb' && aType !== 'bomb' && aEmoji){
    activateBombWithColor(r2,c2,aEmoji);
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(220);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }
  if( (aType==='bomb' && bType==='striped') || (bType==='bomb' && aType==='striped') ){
    const bombPos = (aType==='bomb') ? {r:r1,c:c1} : {r:r2,c:c2};
    const stripePos = (aType==='striped') ? {r:r1,c:c1} : {r:r2,c:c2};
    const targetEmoji = (aType==='striped') ? aEmoji : bEmoji;
    activateStripedAt(stripePos.r, stripePos.c);
    activateBombWithColor(bombPos.r, bombPos.c, targetEmoji);
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(260);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }
  if(aType==='striped' && bType==='striped'){
    let cleared = 0;
    for(let cc=0; cc<COLS; cc++){
      if(board[r1][cc].emoji || board[r1][cc].type){ board[r1][cc].emoji=null; board[r1][cc].type=null; setTileVisual(board[r1][cc]); cleared++; }
    }
    for(let rr=0; rr<ROWS; rr++){
      if(board[rr][c2].emoji || board[rr][c2].type){ board[rr][c2].emoji=null; board[rr][c2].type=null; setTileVisual(board[rr][c2]); cleared++; }
    }
    score += cleared * 95;
    beep(650,0.12,'sawtooth',0.1);
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(240);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }
  if(aType==='striped' && bType!=='striped'){
    activateStripedAt(r1,c1);
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(220);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }
  if(bType==='striped' && aType!=='striped'){
    activateStripedAt(r2,c2);
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    await sleep(220);
    applyGravity(); refillBoard();
    resolveMatchesChain();
    checkLevelEnd();
    return;
  }

  // Normal swap
  swapModel(r1,c1,r2,c2);
  await animateSwapVisual(r1,c1,r2,c2);
  const matches = findAllMatches();
  if(matches.length === 0){
    swapModel(r1,c1,r2,c2);
    await animateSwapVisual(r1,c1,r2,c2);
    beep(220,0.06,'sine',0.05);
    return;
  } else {
    movesLeft = Math.max(0, movesLeft-1);
    updateHUD();
    resolveMatchesChain();
    checkLevelEnd();
  }
}

function swapModel(r1,c1,r2,c2){
  const a = { type: board[r1][c1].type, emoji: board[r1][c1].emoji, stripeDir: board[r1][c1].stripeDir };
  board[r1][c1].type = board[r2][c2].type;
  board[r1][c1].emoji = board[r2][c2].emoji;
  board[r1][c1].stripeDir = board[r2][c2].stripeDir;
  board[r2][c2].type = a.type; board[r2][c2].emoji = a.emoji; board[r2][c2].stripeDir = a.stripeDir;
  setTileVisual(board[r1][c1]); setTileVisual(board[r2][c2]);
}

/* ---------------------------
   Hints
   ---------------------------*/
function findHint(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const neigh = [[r+1,c],[r-1,c],[r,c+1],[r,c-1]];
      for(const n of neigh){
        const r2=n[0], c2=n[1];
        if(!inBounds(r2,c2)) continue;
        swapModel(r,c,r2,c2);
        const matches = findAllMatches();
        swapModel(r,c,r2,c2);
        if(matches.length>0) return [{r,c},{r:r2,c:c2}];
      }
    }
  }
  return null;
}
function showHint(){
  const h = findHint();
  if(!h) { alert('Koi valid hint nahi mila.'); return; }
  const a = board[h[0].r][h[0].c].el;
  const b = board[h[1].r][h[1].c].el;
  a.classList.add('selected'); b.classList.add('selected');
  setTimeout(()=>{ a.classList.remove('selected'); b.classList.remove('selected'); }, 1400);
}

/* ---------------------------
   Level / Timer / Flow
   ---------------------------*/
function startLevel(l=1){
  level = l;
  const def = getCurrentLevelDef();
  movesLeft = def.moves;
  timerSeconds = def.timer;
  if(timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  if(timerSeconds !== null){
    timerInterval = setInterval(()=>{
      timerSeconds--;
      updateHUD();
      if(timerSeconds <= 0){
        clearInterval(timerInterval); timerInterval = null;
        endGame(false);
      }
    }, 1000);
  }
  initBoard();
  updateHUD();
}

function checkLevelEnd(){
  const def = getCurrentLevelDef();
  if(score >= def.target){
    beep(1000,0.24,'sine',0.14);
    alert('Level complete! Target reached. Next level unlock.');
    level++;
    startLevel(level);
    return;
  }
  if(movesLeft <= 0){
    endGame(false);
  }
}

function endGame(success){
  if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
  if(success){
    alert('Congratulations! You cleared the level.');
  } else {
    alert('Game Over â€” Moves/Time finished. Score: ' + score);
  }
}

/* ---------------------------
   UI Buttons
   ---------------------------*/
document.getElementById('btnNew').addEventListener('click', ()=>{ score=0; startLevel(1); });
document.getElementById('btnHint').addEventListener('click', ()=> showHint());
document.getElementById('btnSound').addEventListener('click', function(){ soundOn = !soundOn; this.textContent = 'Sound: ' + (soundOn? 'ON':'OFF'); });
document.getElementById('btnNextLevel').addEventListener('click', ()=>{ level++; startLevel(level); });

/* ---------------------------
   Start
   ---------------------------*/
startLevel(1);
</script>

</body>
</html>
<!-- End of file DEVELEMENT%20COURSE/Game/FruitsGame.html -->
